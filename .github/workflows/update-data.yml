name: Build pokemon_data.csv from SearchDex data (full replacement)

on:
  workflow_dispatch: {}
  schedule:
    - cron: "0 9 * * *"   # Daily 09:00 UTC; adjust as needed

permissions:
  contents: write

jobs:
  build-csv:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout this repo
        uses: actions/checkout@v4

      - name: Fetch SearchDex data files (PokeRogue-Dex)
        id: fetch
        run: |
          set -euxo pipefail
          mkdir -p website/lang

          # Download the SearchDex data files used by the site.
          # (These are generated from the PokÃ©Rogue game source.)
          curl -fL -o website/pokedex_data.js \
            https://raw.githubusercontent.com/Sandstormer/PokeRogue-Dex/main/pokedex_data.js
          curl -fL -o website/filter_data.js \
            https://raw.githubusercontent.com/Sandstormer/PokeRogue-Dex/main/filter_data.js
          curl -fL -o website/lang/en.js \
            https://raw.githubusercontent.com/Sandstormer/PokeRogue-Dex/main/lang/en.js

          # Record the source version from Dex main
          DEX_SHA="$(git ls-remote https://github.com/Sandstormer/PokeRogue-Dex.git refs/heads/main | awk '{print $1}')"
          echo "dex_sha=$DEX_SHA" >> "$GITHUB_OUTPUT"
          echo "dex_short=${DEX_SHA:0:7}" >> "$GITHUB_OUTPUT"

      - name: Convert JS -> CSV (Node VM sandbox)
        shell: bash
        run: |
          node - <<'NODE'
          const fs = require('fs');
          const vm = require('vm');

          const PO = 'website/pokedex_data.js';
          const FI = 'website/filter_data.js';
          const LA = 'website/lang/en.js';
          const OUT = 'pokemon_data.csv';

          function loadLiteralFromFile(path) {
            // Read file, drop 'export' or 'export default' and optional LHS, keep RHS literal.
            let txt = fs.readFileSync(path, 'utf8');
            txt = txt.replace(/\bexport\s+(default\s+)?/g, '').trim();
            const m = txt.match(/=\s*/);
            if (m) txt = txt.slice(m.index + m[0].length).trim();
            txt = txt.replace(/;\s*$/, ''); // strip trailing semicolon
            // Evaluate JS literal safely in a new context and return the value
            return vm.runInNewContext('(' + txt + ')', Object.create(null), { timeout: 2000 });
          }

          function evalGlobals(path, names) {
            // Evaluate entire script in an empty context (no Node globals)
            const code = fs.readFileSync(path, 'utf8').replace(/\bexport\s+(default\s+)?/g, '').trim();
            const ctx = Object.create(null);
            vm.createContext(ctx);
            vm.runInContext(code, ctx, { timeout: 3000 });
            const out = {};
            for (const n of names) out[n] = ctx[n];
            return out;
          }

          // Load data
          const pokedex = loadLiteralFromFile(PO);            // array of species/form dicts
          const lang    = evalGlobals(LA, ['speciesNames', 'fidToName']); // arrays
          const fids    = evalGlobals(FI, ['fidThreshold']).fidThreshold; // [typesUpper, abilitiesUpper, ...]

          // Build mapping tables from lang
          const speciesNames = Array.isArray(lang.speciesNames) ? lang.speciesNames : [];
          const fidToName    = Array.isArray(lang.fidToName) ? lang.fidToName : [];
          const abilityUpper = Array.isArray(fids) && fids.length > 1 ? Number(fids[1]) : null;

          const speciesMap = {};
          for (let i = 0; i < speciesNames.length; i++) {
            const nm = speciesNames[i];
            if (typeof nm === 'string' && nm) speciesMap[i + 1] = nm; // JS arrays 0-based; our index starts at 1
          }

          const typeMap = {};
          const abMap   = {};
          if (fidToName.length >= 18) {
            for (let i = 0; i < 18; i++) {
              const v = fidToName[i];
              if (typeof v === 'string' && v) typeMap[i] = v;
            }
            const end = abilityUpper && Number.isFinite(abilityUpper) ? Math.min(abilityUpper, fidToName.length) : fidToName.length;
            for (let i = 18; i < end; i++) {
              const v = fidToName[i];
              if (typeof v === 'string' && v) abMap[i] = v;
            }
          }

          // Build families for evolution line output
          const families = new Map(); // fa -> [ [fsSort, idx, name], ... ]
          pokedex.forEach((rec, idx0) => {
            const idx = idx0 + 1;
            if (!rec || typeof rec !== 'object') return;
            const fa = rec.fa;
            const fsVal = rec.fs;
            const name = speciesMap[idx] || `Species #${idx}`;
            if (Number.isInteger(fa)) {
              const arr = families.get(fa) || [];
              arr.push([Number.isInteger(fsVal) ? fsVal : 0, idx, name]);
              families.set(fa, arr);
            }
          });

          // Helpers
          function gs(rec, k) {
            const v = rec?.[k];
            const n = Number(v);
            return Number.isFinite(n) ? n : 0;
          }

          // Generate CSV rows
          const rows = [];
          pokedex.forEach((rec, idx0) => {
            const idx = idx0 + 1;
            if (!rec || typeof rec !== 'object') return;
            const name = speciesMap[idx] || `Species #${idx}`;

            const hp  = gs(rec, 'hp');
            const atk = gs(rec, 'atk');
            const dfn = gs(rec, 'def');
            const spa = gs(rec, 'spa');
            const spd = gs(rec, 'spd');
            const spe = gs(rec, 'spe');
            const bst = Number.isFinite(Number(rec?.bst)) ? Number(rec.bst) : (hp + atk + dfn + spa + spd + spe);

            const t1  = rec.t1; const t2 = rec.t2;
            let type1 = (t1 != null && typeMap[Number(t1)]) ? typeMap[Number(t1)] : '';
            let type2 = (t2 != null && typeMap[Number(t2)]) ? typeMap[Number(t2)] : '';
            if (type2 === type1) type2 = '';

            const abCodes = [];
            for (const k of ['a1','a2','a3','ha']) {
              if (k in rec && rec[k] != null && Number.isFinite(Number(rec[k]))) {
                abCodes.push(Number(rec[k]));
              }
            }
            const abilities = abCodes.map(c => abMap[c] || String(c)).join(', ');

            const passiveCode = rec.pa;
            const passive = (passiveCode != null && abMap[Number(passiveCode)]) ? abMap[Number(passiveCode)] : '';

            // evolution line
            let evoLine = '';
            const fa = rec.fa;
            if (Number.isInteger(fa) && families.has(fa)) {
              const fam = families.get(fa).slice().sort((a,b)=> (a[0]-b[0]) || (a[1]-b[1]));
              const names = [];
              const seen = new Set();
              for (const [, , n] of fam) {
                if (!seen.has(n)) { names.push(n); seen.add(n); }
              }
              evoLine = names.join(', ');
            }

            // id: prefer rec.id else rec.dex else 0
            let idVal = 0;
            if (Number.isFinite(Number(rec?.id))) idVal = Number(rec.id);
            else if (Number.isFinite(Number(rec?.dex))) idVal = Number(rec.dex);

            rows.push({
              name,
              id: idVal,
              hp, attack: atk, defense: dfn, spAttack: spa, spDefense: spd, speed: spe,
              bst, type1, type2,
              abilities, passive, 'evolution line': evoLine
            });
          });

          // Write CSV
          const cols = ['name','id','hp','attack','defense','spAttack','spDefense','speed','bst',
                        'type1','type2','abilities','passive','evolution line'];

          function esc(v) {
            if (v === null || v === undefined) v = '';
            v = String(v);
            return /[",\n]/.test(v) ? '"' + v.replace(/"/g,'""') + '"' : v;
          }
          const lines = [cols.join(',')];
          for (const r of rows) {
            lines.push(cols.map(c => esc(r[c])).join(','));
          }
          fs.writeFileSync(OUT, lines.join('\n'), 'utf8');
          console.log('Wrote', OUT, 'rows=', rows.length);
          NODE

      - name: Write data_version.txt (Dex commit)
        run: |
          echo "PokeRogue-Dex ${{ steps.fetch.outputs.dex_short }}" > data_version.txt

      - name: Commit updated CSV + version (if changed)
        run: |
          set -euxo pipefail
          git config user.name  "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add pokemon_data.csv data_version.txt
          if ! git diff --cached --quiet; then
            git commit -m "chore(data): auto-update from PokeRogue-Dex ${{ steps.fetch.outputs.dex_short }}"
            git push
          else
            echo "No changes."
